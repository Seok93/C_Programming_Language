## 스트림과 데이터의 이동
1. 입력이란 프로그램 안으로 데이터가 흘러들어오는 것 (키보드→프로그램 etc)   
   출력이란 프로그램에서 밖으로 데이터가 흘러나가는 것 (프로그램→모니터 etc)   
2. 스트림이란 데이터의 이동경로를 의미하는데, 데이터를 입출력 하기 위해 두 대상(ex 프로그램과 모니터, 프로그램과 키보드)을 연결 시켜주는 다리의 역할을 한다.   
3. 운영체제는 외부 장치와 프로그램 과의 데이터 송수신의 도구가 되는 스트림을 제공하고 있다.   
4. 콘솔(= 일반적으로 키보드, 모니터) 입출력과 파일입출력의 차이점은 파일과의 연결을 의한 스트림의 생성은 우리가 직접 요구해야하지만, 콘솔과의 연결을 위한 스트림의 생성은 요구할 필요없이 자동 생성된다.   
    * 콘솔 입출력을 위한 '입력 스트림'과 '출력 스트림'은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다. 즉, 표준 스트림(standard stream)이다.   
5. 표준 스트림은 3가지이다.   
    |표현      |스트림 종류       |대상               | 
    |:--------:|:---------------: |:-----------------:|
    |stdin     |표준 입력 스트림  |키보드 대상으로 입력|
    |stdout    |표준 출력 스트림  |모니터 대상으로 출력|
    |stderr    |표준 에러 스트림  |모니터 대상으로 출력|
    * 입출력 리다이렉션(redirection)을 통해 에러를 파일로 모으는 등 변경 가능하다.   

## 문자 단위 입출력 함수
1. 문자 출력함수 putchar, fputc : 하나의 문자를 출력할 때 사용   
   ```
   #include <stdio.h>
   int putchar(int c);
   int fputc(int c, FILE * stream);
   → 함수 호출 성공시 쓰여진 문자정보가, 실패시 EOF 반환
   ```
    * putchar 함수는 인자로 전달된 문자 정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수이다.   
    * fputc 함수는 문자를 전송할 출력스트림(stdout, file etc)을 지정할 수 있다.   

2. 문자 입력함수 getchar, fgetc : 하나의 문자를 입력 받을 때 사용   
   ```
   #include <stdio.h>
   int getchar(void);
   int fgetc(FILE * stream);
   → 파일의 끝에 도달하거나 함수 호출 실패시 EOF 반환
   ```
    * getchar 함수는 stdin으로 표현되는 표준 입력스트림으로부터 하나의 문자를 입력 받아서 반환하는 함수이다.   
    * fgetc 함수는 문자를 입력 받을 입력스트림(stdin, file etc)을 지정할 수 있다.   

3. EOF는 End Of File의 약자로 파일의 끝을 표현하기 위해 정의해 놓은 상수(-1)이다.   
4. 엔터키는 아스키코드값이 10('\n')인 문자이다.   
5. 표준 입력 장치(키보드)로부터 EOF를 반환 받는 이유 2가지   
    ① 함수호출의 실패   
    ② Windows: Ctrl+Z, Linux: Ctrl+D 입력시   

## 문자열 단위 입출력 함수
1. 문자열 출력 함수: puts, fputs : 하나의 문자열을 출력할 때   
   ```
   #include <stdio.h>
   int puts(const char *s);
   int fputs(const char *s, FILE * stream);
   → 성공 시 음수가 아닌 값을, 실패 시 EOF 반환
   ```
    ① puts 함수는 표준 출력스트림(stdout)으로부터 하나의 문자열을 전송한다.   
    ② fputs 함수는 지정한 출력스트림(stdout)으로부터 하나의 문자열을 전송한다.   
    * puts함수는 문자열 출력 후 자동으로 개행, fputs 함수기 호출되면 문자열 출력 후 자동으로 개행이 이뤄지지 않는다. fputs는 지정한 출력스트림에 따라 파일에도 출력이 가능한데, 파일에 출력할 때마다 자동으로 개행되면 곤란하기 때문이다.   

2. 문자열 입력 함수: gets,fgets : 하나의 문자열을 입력할 때    
   ```
   #include <stdio.h>
   char* gets(char *s);
   char* fgets(char *s, int n, FILE * stream);
   → 파일의 끝에 도달하거나 함수호출 실패 시 NULL 포인터 반환
   ```
    ① gets 함수는 미리 마련해 놓은 배열을 넘어서는 길이의 문자열이 입력되면, 할당 받지 않은 메모리 공간을 침범하여 실행 중 오류가 발생한다는 단점이 있다. (가급적 fgets로 쓸것)   
    ② fgets 함수는 미리 마련해 놓은 배열을 넘어서면, 딱 미리 마련해둔 배열만큼만 읽어오고 초과분은 버퍼에 그대로 두게 된다. 또한 문자열 맨 마지막엔 무조건 널문자('\0')가 들어가야 함으로 입력 받을 수 있는 문자열의 길이는 [배열의길이-1]이 된다.   
    * fgets함수는 엔터(\n)을 만날 때까지 문자열을 읽어들이는데, \n을 제외시키거나 버리지 않고 문자열의 일부로 받아들인다.   
    * scanf는 공백문자를 입력 받을 수 없지만, fgets는 공백문자를 입력받을 수 있다.    

## 표준 입출력과 버퍼
1. 메모리 버퍼란 데이터를 임시로 저장하는 메모리 공간이다. 입력 버퍼에 저장하는 것을 버퍼링이라고도 한다.   
2. 표준 입출력 함수(printf, fputc etc)를 통해서 데이터를 입출력 하는 경우, 해당 데이터들은 운영체제가 제공하는 메모리버퍼를 중간에 통과하게 된다.   
3. 스트림 중간에 출력버퍼와 입력버퍼를 두고 전송하고자 하는 데이터를 임시적으로 저장하는 이유는 데이터 전송의 효율성 때문이다. 키보드나 모니터 같은 외부장치의 데이터 입출력은 생각보다 시간이 많이 걸리는 작업이다. 때문에 올 때마다 프로그램까지 데이터를 하나씩 옮기는 것보다 버퍼라는 임시공간에 모아서 한 번에 가져오는게 더 빠르다.   
4. 출력버퍼가 비워진다는 것은 출력버퍼에 저장된 데이터가 버퍼를 떠나서 목적지로 이동됨을 의미하는데, 출력버퍼가 비워지는 시점은 시스템에 따라 그리고 버퍼의 성격에 따라 다르다. 그렇기 때문에 전달된 스트림의 버퍼를 비우는 기능이 필요하고 fflush함수가 그 역할을 해준다. 어떠한 시스템의 어떠한 표준 출력버퍼라 할지라도 버퍼에 저장된 내용이 지워지면서 데이터가 목적지로 이동한다.   
   ```
   #include <stdio.h>
   int ffulsh(FILE * stream);
   → 함수호출 성공시 0, 실패시 EOF반환
   ```
5. 출력버퍼의 비워짐과 입력버퍼의 비워짐은 개념적으로 차이가 있는데, 출력버퍼의 비워짐은 저장된 데이터가 목적지로 전송되는 반면 입력버퍼의 지워짐은 데이터의 소멸을 의미한다.   
6. 입력 버퍼를 비우는 함수는 표준으로 정의되어 있지는 않지만, 그 역할을 하도록 만들 수 는 있다.   
   ```
   ex)
       // 개행문자를 만날 때까지 읽어드려서 소멸시킨다.
       void ClearLineFromReadBuffer(void) {
         while(getchar() != '\n');
       }
   ```
## 입출력 이외의 문자열 관련 함수
string.h에는 문자열에 관련된 여러 표준함수들이 정리되어있다.   
1. strlen 함수 : 문자열의 길이를 반환하는 함수   
   ```
   #include <string.h>
   size_t strlen(const char *s); // size_t는 unsigned int를 의미
   → 전달된 문자열의 길이를 반환하되, 널 문자는 길이에 포함하지 않는다.
   ```
   ```
   ex) 
     char str[] = "1234567";
     printf("%u \n", strlen(str));
   ```
2. strcpy 함수, strncpy함수 : 문자열의 복사에 사용되는 함수   
   ```
   #include<string.h>
   char * strcpy(char * dest, const char * src);
   char * strncpy(char * dest, const char * src, size_t n);
   → 복사된 문자열의 주소 값 반환
   ```
   ① strcpy함수는 복사할 문자열보다 입력받을 문자열의 배열의 길이가 작지 않도록 주의해야한다.   
   ② strncpy함수는 행여나 복사할 문자열보다 입력받을 문자열의 배열의 길이가 작을 경우, 해당 부분까지만 읽어드리도록 크기를 제한해준다. 문제는 자동으로 널문자('\0')를 삽입해주지 않으므로 인위적으로 넣어줘야한다.   

3. strcat, strncat 함수 : 문자열을 덧붙이는 함수   
   ```
   #include<string.h>
   char * strcat(char * dest, const * src);
   char * strncat(char * dest, const * src, size_t n);
   → 덧붙여진 문자열의 주소값 반환
   ```
   ① strcat는 두 문자열을 그대로 붙여준다.   
   ② strncat는 붙일 문자열 중 몇글자만 붙일지 지정할 수 있다. 참고로 8문자를 복사한 후 널문자가 포함되기 때문에 실제로는 9개가 붙는다.   

4. strcmp, strncmp 함수 : 문자열 비교 함수   
   ```
   #include<string.h>
   int strcmp(const char * s1, const char * s2);
   int strncmp(const char * s1, const char * s2, size_t n);
   → 두 문자열의 내용이 같으면 0, 같지 않으면 0 이 아닌 값을 반환
   ```
   s1이 s2보다 크면 0보다 큰 값   
   s1이 s2와 같으면 0 을 반환   
   s1이 s2보다 작으면 0보다 작은 값   
   → 아스키코드값으로 비교하기 때문인데, 큰값이 나오면 사전 순상 뒤로 간다.    

5. 문자열에서 정수 혹은 실수로 변환   
   ```
   #include<stdlib.h>
   int atoi(const char * str);
   long atol(const char * str);
   double atof(const char * str);
   ```
   ① atoi함수는 문자열의 내용을 int형으로 반환   
   ② atol함수는 문자열의 내용을 long형으로 반환   
   ③ atof함수는 문자열의 내용을 double형으로 반환   
