## 파일과 스트림 그리고 기본적인 파일의 입출력
1. 파일을 대상으로 입출력을 하고 싶다면 이 또한 스트림을 형성해야한다. 콘솔의 스트림은 운영체제가 자동으로 생성해주지만, 파일의 스트림은 우리가 운영체제에게 만들어달라고 직접 요구 해야한다.   
2. fopen함수는 스트림을 형성할 때 호출하는 함수이다.   
  ```
  #include <stdio.h>
  FILE * fopen(const char* filename, const char* mode);
  → 성공시 해당 파일의 FILE구조체 변수의 주소값, 실패시 NULL포인트 반환
  ```
  ① 첫번째 인자는 스트림을 형성할 파일이름, 두번째 인자로는 형성할 스트림의 종류이다.   
  ② 함수 호출 후 FILE구조체의 주소를 반환 받는데, 이를 통해 입출력을 실행한다.   
  
3. 스트림은 한 방향으로 흐르는 데이터의 흐름이므로, 파일로부터 읽어들이는 입력스트림인가, 데이터를 파일에 쓰기 위한 출력스트림인가 구별해야한다.   
  ```
  ex 1) FILE * fp = fopen("data.txt", "wt"); // 출력스트림의 형성
        // wt모드의 스트림은 텍스트데이터를 쓰기 위한 출력스트림이다.
        // 출력스트림이기 때문에 파일에 데이터를 쓸 수는 있어도 읽지는 못한다.
  ```
  ```
  ex 2) FILE * fp = fopen("data.txt", "rt"); // 입력스트림의 형성
        // rt모드의 스트림은 텍스트 데이터를 읽기 위한 입력스트림이다. 
  ```
4. fclose함수는 스트림의 해제하는 함수이다.   
  ```
  #include <stdio.h>
  int fclose(FILE * stream);
  → 성공시 0, 실패시 EOF를 반환
  ```
5. 파일을 fclose함수를 통해 인위적으로 닫아줘야하는 이유는 2가지이다.   
  ① 운영체제가 할당한 자원의 반환   
  ② 버퍼링 되었던 데이터의 출력   
6. 스트림의 형성을 요청하는 것은 우리지만, 실제로 스트림을 형성하는 주체는 운영체제이다. 그리고 운영체제는 스트림의 형성을 위해서 시스템의 자원을 할당한다. 그런데 파일을 닫아주지 않으면 할당된 채로 남아있게 되어, 그만큼의 자원손실을 초래한다. 파일 관련 작업이 끝났다면 즉시 fclose함수를 사용하자.   
7. 파일 스트림의 경우에도 성능향상을 도모하기 위해 중간에 입력버퍼와 출력버퍼가 있다. 이런 구조에서 문제는 파일에 저장되기 직전에 컴퓨터의 전원이 나간다면 버퍼에 있던 데이터가 소실되고, 파일에는 저장되어 있지 않는다.   
8. 파일 스트림의 출력은 파일스트림의 종료와 동시에 일어나는데, 파일스트림을 종료하지 않고 버퍼만 비우고 싶을 때에는 fflush함수를 호출하면 된다.   

## 파일의 개방모드
1. 스트림의 종류가 다양한데, 크게 2가지의 기준을 통해서 스트림을 구분하게 된다.   
  ① 스트림의 이동방향 (입력스트림/출력스트림)   
  ② 파일에 담을 수 있는 데이터 유형 (텍스트스트림/바이너리스트림)   

2. 스트림의 이동방향에 따른 4가지 구분   
  ① 데이터 READ 스트림        // 읽기만 가능   
  ② 데이터 WRITE 스트림       // 쓰기만 가능   
  ③ 데이터 APPEND 스트림      // 쓰되 덧붙여 쓰기가능   
  ④ 데이터 READ/WRITE 스트림  // 읽기, 쓰기 모두 가능   

  | 모드   | 스트림의성격                 | 파일이 없으면?|
  | :----: | :-------------------------: | :-----------: |
  | r      | 읽기 가능                    | 에러          |
  | w      | 쓰기 가능                    | 생성          |
  | a      | 파일의 끝에 덧붙여 쓰기 가능 | 생성          |
  | r+     | 읽기/쓰기 가능               | 에러          |
  | w+     | 읽기/쓰기 가능               | 생성          |
  | a+     | 읽기/덧붙여 쓰기 가능        | 생성          |

3. r+, w+, a+가 읽기/쓰기가 다 가능해서 더 좋은 모드라 생각할 수 있다. 그러나 이러한 모드를 기반으로 작업하는 경우에는 읽기에서 쓰기, 쓰기에서 읽기로 작업을 변경할 때마다 메모리 버퍼를 비워줘야 하는 등의 불편함과 더불어 잘못된 사용의 위험성이 동반된다. 차라리 r, w, a 중에서 하나를 선택하여 스트림을 형성하는 것이 좋으며, 이것이 보다 일반적인 선택이다.   

4. 파일에 담을 수 있는 데이터 유형에 따른 2가지 구분   
  ① 텍스트 데이터 // 사람이 인식할 수 있는 문자를 담고 있는 파일   
  ② 바이너리 데이터 // 컴퓨터가 인식할 수 있는 데이터(정수형)를 담고 있는 파일   

  | 모드   | 스트림의성격                 |
  | :----: | :-------------------------: |
  | t      | 텍스트 데이터 (defalut)      | 
  | b      | 바이너리 데이터              |

  * 바이너리 데이터 예시: 음원파일, 영상파일 etc

5. 개행은 일반적인 문자 데이터와 성격이 조금 다르다. 개행은 줄이 바뀌었다는 일종의 현상이지 그 자체가 하나의 데이터로 존재하는 대상은 아니다. 또한 개행의 표현은 운영체제마다 차이가 있기 때문에 개행문자가 포함되는 텍스트 데이터의 저장에는 주의가 필요하다.   

  | OS              | 개행문자 |
  | :-------------: | :------: |
  | MS-DOS(Windows) | \r\n     |
  | Mac             | \r       |
  | Unix계열        | \n       |

  * 파일을 텍스트모드로 개방하면 OS별로 개행문자를 자동으로 맞춰준다.   

## 파일 입출력 함수의 기본
1. 파일에서는 개행을 기준으로 문자열을 구분하기 때문에, 문자열이 파일에 저장될 때에는 문자열의 끝을 의미하는 널문자는 저장되지 않는다.   
2. 문자 입/출력, 문자열 입/출력을 담당하는 함수들   
int fputc(int c, FILE* stream);           // 문자 출력   
int fgetc(FILE* stream);                  // 문자 입력   
int fputs(const char* s, FILE* stream)    // 문자열 출력   
char& fgets(char* s, int n, FILE* stream) // 문자열 입력   
3. feof함수는 파일의 끝에 도달했는가 확인해주는 함수이다. FILE구조체의 포인터를 대상으로 더이상 읽어 들일 데이터가 존재하지 않으면 0이 아닌 값을 반환한다.
  ```
  #include <stdio.h>
  int feof(FILE * stream);
  → 파일의 끝에 도달한 경우 0이 아닌 값 반환
  ``
4. fread, fwrite함수는 바이너리 데이터의 입출력 함수이다.
  ```
  #include <stdio.h>
  size_t fread(void * buffer, size_t size, size_t count, FILE* stream);
  → 성공시 전달인자 count, 실패 또는 파일의 끝 도달시 count보다 작은 값 반환
  ```
  ```
  ex) 
     int buf[12];
     fread((void*) buf, sizeof(int), 12, fp);
     // sizeof(int) 크기의 데이터 12개를 fp로부터 읽어 들여서 배열 buf에 저장하라는 의미이다.
  ```
  ① fread함수는 두 번째 전달인자와 세 번째 전달인자의 곱의 바이트 크기만큼 데이터를 읽어 들이는 함수이다.   
  ② fread함수는 실제로 읽어들인 데이터의 갯수를 반환한다. 파일의 끝에 도달해 12개를 모두 읽어 들이지 못했거나 오류가 발생하는 경우에는 12보다 작은 값이 반환된다.   
  ```
  #include <stdio.h>
  size_t fwrite(const void * buffer, size_t size, size_t count, FILE * stream );
  → 성공 시 전달인자 count, 실패시 count보다 작은 값 반환
  ```
  ```
  ex) 
     int buf[7] = {1, 2, 3, 4, 5, 6, 7};
     fread((void*) buf, sizeof(int), 7, fp);
     // sizeof(int)크기의 데이터 7개를 buf로부터 읽어서 fp에 저장하라는 의미이다.
  ```
## 텍스트 데이터와 바이너리 데이터를 동사에 입출력하기
1. fprintf, fscanf함수는 텍스트 데이터와 바이너리 데이터를 파일에 동시에 입/츨력할 때 사용하는 함수이다.   
  ```
  ex)
     char name[10] = "홍길동"; // 텍스트 데이터
     char sex = 'M'; // 텍스트 데이터
     int age = 24;  // 바이너리 데이터
     fprintf(fp, "%s %c %d", name, sex, age); // FILE구조체 변수 fp를 대상으로 서식에 따른 데이터를 출력해준다.
  ```

2. fprintf는 printf와 사용법이 같고, fscanf는 scanf와 사용법이 같다. 단지 첫 번째인자로 파일 스트림을 넣어준다.    
3. fscanf함수는 파일의 끝에 도달하거나 오류가 발생하면 EOF를 반환한다.   
4. 텍스트와 바이너리 데이터의 집합체인 구조체 변수의 입출력에도 쓰인다. 구조체 변수를 하나의 바이너리 데이터로 인식하고 처리하면 된다.   

## 임의 접근을 위한 파일 위치 지시자의 이동
1. FILE 구조체의 멤버 중에는 파일의 위치 정보(어디까지 읽었는지 에 대한 위치정보)를 저장하고 있는 멤버가 있는데, 이 멤버의 값은 fgets, fputs 또는 fread, fwrite와 같은 함수가 호출될 때마다 참조 및 갱신 된다.   
2. 파일 위치 지시자는 파일이 처음 개방되면 무조건 파일의 맨 앞부분을 가리킨다. 만약 파일의 준간 혹은 마지막 부분에서부터 데이터를 읽거나 쓰기를 원한다면 파일 위치 지시자를 이동시켜야한다.   
3. fseek함수는 파일 위치 지시자를 이동시키는 함수이다.   
  ```
  #include <stdio.h>
  int fseek(FILE* stream, long offset, int wherefrom);
  →　성공 시 0, 실패 시 0이 아닌 값을 반환
  // offset은 음의 값이 전달될 수 있다.
  ```
  | 매개변수 wherefrom의 종류 | 기준 위치                          |
  | :----------------------: | :--------------------------------: |
  | SEEK_SET                 | 파일 맨 앞에서부터 이동을 시작      |
  | SEEK_CUR                 | 현재 위치에서부터 이동을 시작       |
  | SEEK_END                 | 파일 맨 끝(EOF)에서부터 이동을 시작 |
  
  ① SEEK_SET 전달 시 첫번째 바이트에서부터 이동을 시작   
  ② SEEK_END 전달 시 EOF에서부터 이동을 시작한다.   
  ③ fseek함수의 두 번째 인자로 음수가 전달되면 왼쪽으로 이동한다.   

4. ftell함수는 현재 파일 위치 지시자의 위치를 알려주는 함수이다.   
  ```
  #include <stdio.h>
  long ftell(FILE * stream);
  → 파일 위치 지시자의 위치 정보 반환
  // 첫 번째 바이트를 가리킬 경우 0, 세 번째 바이트를 가리킬 경우 2이다.
  ```