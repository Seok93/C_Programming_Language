함수호출시 전달되는 인자의 값은 매개변수에 복사가 되기 때문에, 함수가 호출되고 나면 전달되는 인자와 매개변수는 값이 같지만 별개의 메모리공간에 저장이 된다. 때문에 함수에서도 전달인자와 같은 메모리공간을 사용하기 위해서는 포인터를 잘 활용해야한다.

## 함수의 인자로 배열 전달하기
1. 함수를 호출하면서 매개변수에 배열을 통째로 넘겨주는 방법은 존재하지 않는다. 대신 함수 내에서 배열에 접근할 수 있도록 배열의 시작 주소값을 전달하여 접근하는 것은 가능하다.   
```
ex)
   void SimpleFunc(int * param) { ... } // 주소를 받기위해 매개변수를 포인터로 지정
   int main(void) {
     int arr[3] = {1, 2, 3};
     SimpleFunc(arr);  // SimpleFunc에 메모리주소 전달
   }
```
2. 함수의 매개변수에 한하여 배열의 길이를 지정하지 않은 배열을 선언하여 주소값을 직접 받는 것이 가능하다.   
```
ex)
   void ShowArayElem(int * param, int len) { ... }
   void ShowArayElem(int param[], int len) { ... }
   // 둘은 같은 표현방법이다. 
```
3. 함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없기 때문에 반드시 길이정보를 같이 전달해줘야한다.   
## Call-by-value와 Call-by-reference
1. 함수 호출시 단순히 값을 전달하는 형태의 함수호출을 Call-by-value라고 한다.   
2. 메모리 접근에 사용되는 주소값을 전달하는 형태의 함수호출을 Call-by-reference라고 한다.   

## 포인터 대상의 const 선언
1. 보통 const 키워드는 일반 자료형보다 앞에 선언하여 변수를 상수화한다.   
2. 포인터에서는 const 위치에 따라 포인터가 가리키는 값을 상수화하거나 포인터에 저장된 주소값을 상수화하여 변경이 불가능하게 한다.   
```
ex 1) 가리키는 값의 변경을 제한
    const int * ptr = &num; // 포인터변수 ptr을 이용해서 ptr이 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다.
```
```
ex 2) 저장된 메모리 주소값의 변경을 제한
   int * const ptr = &num; // 포인터변수 ptr 자체가 상수화가 되어, 저장된 주소값을 변경하는 것을 허용하지 않는다.
```
* const를 사용하면 컴파일러가 문제점을 지적해주기 때문에 프로그램의 안정성이 상승한다. 