# 매크로와 선행처리기
## 매크로와 선행처리기
1. 컴파일 이전에 선행처리라는 과정을 거치게 된다. 컴파일 과정을 거치게 되면 바이너리 데이터로 이루어진 오브젝트 파일이 생성 된다.   
2.선행처리기가 하는 일은 삽입해 놓은 선행처리 명령문대로 소스코드의 일부를 수정할 뿐이다. 그래서 선행처리의 과정을 거쳐서 생성되는 파일도 그냥 소스파일일 뿐이다.   
3. 선행 처리 명령문은 #문자로 시작하며, 컴파일러가 아닌 선행처리기에 의해서 처리되는 문장이기 때문에 명령문의 끝에 세미콜론을 붙이지 않는다.   

## 대표적인 선행처리 명령문
1. 선행처리의 명령문은 기본적으로 세 부분으로 나뉘는데 지시자, 매크로, 매크로몸체로 나뉜다.   
2. #define 지시자를 통해 매크로 부분을 매크로 몸체부분으로 치환해준다.   
   ```
   ex) #define PI 3.1415
   ```
3. 매크로의 이름은 대문자로 정의하는 것이 일반적이며, 복수의 단어로 이루어질 경우 _를 통해 연결한다.   
4. 매크로 몸체로 함수의 호출이 와도 된다.   
5. 매크로는 매개변수가 존재하는 형태로도 정의할 수 있다. 이렇게 정의한 매크로는 그 동작방식이 마치 함수와 유사하여 함수와 유사한 매크로(function-like macro)라하며 줄여서 매크로함수라고 한다.   
   ```
   ex) #define SQUARE(X) X*X
   ```

6. 매크로함수를 정의할 때 매크로몸체의 전달인자 하나하나에 괄호를 다 쳐주는게 안정적인 연산을 하도록 도와준다.   
   ```
   ex) #define SQUARE(X) ((X)*(X))
   ```

7. 매크로는 기본적으로 한 줄에 정의하는 것이 원칙이지만, 가독성을 위해 두줄 이상으로 정의하는 법을 제공해준다. 그때 사용하는 것이 \ 이다.   
   ```
   ex) #define SQUARE(X) \
               ((X)*(X))
   ```

8. 매크로 정의 시, 먼저 정의된 매크로를 사용해도 된다.   
   ```
   ex) #define PI 3.14
       #define PRODUCT(X, Y) ((X)*(Y))
       #define CIRCLE_AREA(R) (PRODUCT((R), (R)) * PI)
   ```

9. 매크로 함수의 장점은 일반 함수에 비해 실행속도가 빠르고, 자료형에 따라서 별도로 함수를 정의하지 않아도 된다. 실행속도가 빠른 이유는 함수를 위한 스택 메모리 할당, 매개변수로의 인자 전달, return문에 의한 값의 반환 등이 일체 필요하지 않기 때문이다.   

10. 매크로 함수의 단점은 정의하기가 까다롭고 디벙깅하기가 쉽지 않다는 점이다. 매크로를 잘못 정의할 경우, 매크로를 잘못 정의할 경우, 에러메시지는 선행처리 이전의 소스파일을 기준으로 출력되지 않고, 선행처리 이후의 소스파일을 기준으로 출력된다.   

## 조건부 컴파일을 위한 매크로 (Conditional Compilation)
1. 특정 조건에 따라 소스코드의 일부를 삽입하거나 삭제할 수 있도록 디자인 된 지시자가 있다.   
2. #if... #endif은 조건부 코드 삽입을 위한 지시자로, 조건이 참인가 거짓인가에 의해 코드를 삽입할지 결정한다.   
   ```
   ex)
       #if ADD
	       printf("%d + %d = %d \n", num1, num2, num1+num2);
       #endif
   ```
3. #ifdef...#endif는 조건부 코드 삽입을 위한 지시자로, #if...#endif가 조건이 참인가를 판단하는 것이라면, #ifdef...#endif는 매크로가 정의되어있느냐 아니냐를 기준으로 조건부 코드 삽입을 한다.   

4. #ifndef...#endif도 조건부 코드 삽입을 위한 지시자로, #ifdef...#endif가 매크로가 정의되었는가 확인한다면, #ifndef...#endif는 매크로가 정의되지 않았는가를 확인하여 조건부 코드 삽입을 실행한다. 이 매크로는 헤더파일의 중복포함을 막기 위해 주로 사용한다.   

5. #if, #ifdef, #ifndef에는 #elif오 #else를 사용하여 분기점을 만들어 줄 수 있다.   

## 매개변수의 결합과 문자열화
1. 문자열 내에서는 매크로의 매개변수 치환이 발생하지 않는다.   
   ```
   ex) #define STRING_JOB(A, B) "A의 직업은 B입니다.". 
   ```

2. 문자열 내에서 매크로의 매개변수 치환이 발생하기 만들기 위해 #연산자를 사용한다.   
   ```
   ex 1) define STR(ABC) #ABC
         STR(12, 23, 34)  // "12, 23, 34"로 치환
   ```
   ```
   ex 2) #define STRING_JOB(A, B) #A "의 직업은" #B "입니다."
   ```

3. ##연산자를 통해 매크로 함수의 전달인자를 다른 대상과 연결해줄 때 사용한다.   
   ```
   ex) #define CON(UPP, LOW) UPP ## 00 ## LOW
       CON(22, 77);         // 220077
   ```