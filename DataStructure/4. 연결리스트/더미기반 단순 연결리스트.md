## 연결리스트의 개념적 이해

1. 배열은 메모리의 특성이 정적이어서 메모리의 길이를 변경하는 것이 불가능하다는 단점이 있다. (배열로 구현한 순차 리스트의 한계)
2. 연결리스트는 필요 할 때마다 노드를 하나씩 동적 할당하여 정보를 저장하고 이들을 서로 연결한다.
   ```
   ex)
      typedef struct _node {
         LData data;   // 데이터를 저장해주는 변수(LData는 typedef를 이용하여 int부터 구조체까지 다양하게 설정할 수 있다. )
         _node* next;  // 다음 노드를 연결해주는 포인터
      } Node;
   ```
3. 연결리스트를 구현할 때 중요한 역할을 하는 것이 3가지가 있다.  
   ① head : 연결리스트의 시작 노드를 가리키고 있다.  
   ② tail : 연결리스트의 마지막을 가리키며, 새로운 데이터가 들어올 때 저장하는 용도로 사용한다.  
   ③ cur : head를 이용해 시작 노드부터 마지막 노드까지 돌아다니기 위해 사용하는 현재 참조 중인 연결리스트의 위치를 나타낸다.
4. 단순 연결리스트란 연결의 형태가 한쪽 방향으로 전개되고, 시작과 끝이 분명히 존재하는 형태를 말한다.

   ```
   ex)
       (더미 기반) 단순 연결리스트의 ADT
      ・ 리스트 초기화
      ・ 리스트에 데이터 저장
      ・ 리스트의 데이터 참조
      ・ 리스트의 다음 데이터 참조
      ・ 리스트의 데이터 삭제
      ・ 리스트에 저장된 데이터 수
      ・ 리스트 정렬

      struct List {};

      void ListInit(List * plist);
        - 초기화할 리스트의 주소 값을 인자로 전달한다.
        - 리스트 생성 후 제일 먼저 호출되어야 하는 함수이다.

      void LInsert(List * plist, LData data);
        - 매개변수 data에 전달된 값을 리스트에 저장한다.

      int LFirst(List * plist, LData * pdata);
        - 첫 번째 데이터가 pdata가 가리키는 메모리에 저장된다.
        - 데이터의 참조를 위한 초기화가 진행된다.
        - 참조 성공 시 TRUE(1), 실패시 FALSE(0) 반환

      int LNext(List * plist, LData * pdata);
        - 참조된 데이터의 다음 데이터가 pdata가 가리키는 메모리에 저장된다.
        - 순차적인 참조를 위해서 반복 호출이 가능하다.
        - 참조를 새로 시작하려면 먼저 LFirst함수를 호출해야한다.
        - 참조 성공 시 TRUE(1), 실패시 FALSE(0) 반환

      LData LRemove(List * plist);
        - LFirst 또는 LNext함수의 마지막 반환 데이터를 삭제한다.
        - 삭제된 데이터는 반환된다.
        - 마지막 반환 데이터를 삭제하므로 연이은 반복 호출을 허용하지 않는다.

      int LCount(List * plist);
        - 리스트에 저장되어 있는 데이터의 수를 반환한다.

      void SetSortRule(List* plist, int (*comp)(LData d1, LData d2));
        - 리스트에 정렬의 기준이 되는 함수를 등록한다.
   ```

5. 새로운 노드를 head에 저장할지 tail에 저장할지에 따라 장단점이 있다.  
   ① head에 추가시   
   \- 장점: 포인터 변수 tail이 불팔요하다.   
   \- 저장된 순서를 유지하지 않는다.  
   ② tail에 추가시   
   \- 장점: 저장된 순서가 유지된다.   
   \- 단점: 포인터변수 tail이 필요하다.   
   * 보통 head에 추가하는 것을 많이 쓰는데, 이유는 포인터 변수 tail을 유지하기 위해서 넣어야 할 부가적인 코드가 번거롭게 느껴질 수 있고ㅡ 리스트 자료구조는 저장된 순서를 유지해야하는 자료구조가 아니기 때문이다.
6. 연결리스트 시작시 head와 tail에 더미 노드를 추가해서 시작하면, 첫 번째 노드를 포인터 변수 head가 가리킨다는 차이점을 방지할 수 있기 때문에 모든 노드에 공통된 연산을 적용할 수 있다.
