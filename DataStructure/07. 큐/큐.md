## 큐의 이해와 ADT정의

1. 큐는 먼저 넣은 데이터가 먼저 나오는 선입선출(FIFO) 구조를 가진 자료구조이다.
2. 큐는 운영체제나 네트워크 관련 소프트웨어를 만들 때 많이 사용되는 자료구조이다. 혹은 무언가를 시뮬레이션할 때 사용된다.
3. 큐의 핵심 연산으론 Enqueue와 Dequeue가 있다.  
   ① Enqueue는 큐에 데이터를 넣는 연산이다.  
   ② Dequeue는 큐에서 데이터를 꺼내는 연산이다.
4. 큐는 선입선출을 위해 데이터를 뒤로 넣고, 앞으로 빼낸다.

   ```
   ex)
      큐 자료구조의 보편적인 ADT 정의
      ・ 큐 초기화
      ・ 큐가 비었는지 확인
      ・ 큐에 데이터 삽입    (= Enqueue)
      ・ 큐에서 데이터 추출  (= DeQueue)
      ・ 큐에서 데이터 참조

      void QueueInit(Queue* pque);
      - 큐의 초기화를 진행
      - 큐 생성 후 제일 먼저 호출되어야 하는 함수

      int QIsEmpty(Queue* pque);
      - 큐가 빈 경우 TRUE, 그렇지 않은 경우 FALSE

      void Enqueue(Queue* pque, Data data);
      - 큐에 데이터 저장, 매개변수 data로 전달된 값을 저장

      Data Dequeue(Queue* pque);
      - 저장 순서가 가장 앞선 데이터를 삭제 (선입선출)
      - 삭제된 데이터를 반환
      - 데이터가 하나 이상 존재함이 보장되어야 한다.

      Data QPeek(Queue* pque);
      - 저장 순서가 가장 앞선 데이터를 반환하되 삭제하지 않음
      - 데이터가 하나 이상 존재함이 보장되어야 한다.
   ```

## 배열 기반의 큐 구현(= 원형큐)

1. 큐를 구현할 땐 F(Front), R(Rear)을 이용한다.
2. 배열에서도 F와 R을 이용하는데, 첫번째 데이터를 F가 가리키고, 마지막 데이터를 R이 가리키고 있다.
3. 배열 기반으로 큐를 구현할 때, dequeue 연산시 삭제된 데이터를 위해 데이터를 이동할 필요가 없이 F가 앞으로 한 칸 이동하는 연산만 한다.
4. F가 dequeue연산시 계속 인덱스 값을 한 칸씩 이동해가고, R또한 enqueue 연산 시 계속 인덱스 값을 한 칸씩 이동시키므로, 최종적으로 F와 R은 배열의 마지막에 도달하게 된다. 이럴 경우 다시 배열의 첫 번째 요소(0)부터 다시 채워나가야함으로 원형큐가 된다.
5. 큐를 구현할 때 신경써야할점 2가지  
   ① 큐가 꽉 찬 경우  
   ② 큐에서 중간에 데이터가 완전히 비워질 경우  
   → 그림을 그리면서 F와 R을 추적해보면, 위의 2가지의 경우 F가 R보다 한 칸 앞선 위치하게 되는데 이것의 의미는, F와 R의 위치만 가지고는 꽉 찬 경우와 텅 빈 경우를 구분할 수 없다는 것이다.

   해결책: 배열의 길이가 N이라면 데이터가 N-1개 채워졌을 때 꽉찬 것으로 간주하면 위의 문제가 해결된다. 그렇게 하면 큐가 꽉 찬상태와 텅 빈 상태를 구별할 수 있게 된다.  
   ① 큐가 텅 빈 상태: F와 R이 동일한 위치를 가리킨다.  
   ② 큐가 꽉 찬 상태: R이 가리키는 위치의 앞을 F가 가리킨다.

## 연결리스트 기반의 큐 구현

1. 배열 기반으로 큐를 구현하는 경우 몇가지 고려할 사항이 있었고, 그래서 원형 큐를 소개하고 큐가 꽉 찬 경우와 텅 빈 경우를 구분하는 방법도 소개했지만, 연결리스트를 기반으로 구현하면 별로 신경쓰지 않아도 된다.

## 덱의 이해와 구현

1. 덱(Deque)은 double-ended queue를 줄인 말이며, 앞/뒤로 데이터를 넣을 수 있고, 앞/뒤로 데이터를 추출할 수 있는 구조이다. 때문에 스택과 큐를 조합한 형태의 자료구조로 이해되고 있다.
2. 덱을 구현할 때에는 양방향 연결리스트 기반으로 구현하는게 제일 어울리는데, 그 이유는 꼬리에 위치한 노드의 삭제를 구현하는게 간단해지기 때문이다.

   ```
   ex)
      양방향 연결리스트 기반의 덱 자료구조의 보편적인 ADT 정의
      ・ 덱 초기화
      ・ 덱가 비었는지 확인
      ・ 덱의 머리에 데이터 저장
      ・ 덱의 꼬리에 데이터 저장
      ・ 덱의 머리에 위치한 데이터를 반환 및 소멸
      ・ 덱의 꼬리에 위치한 데이터를 반환 및 소멸
      ・ 덱의 머리에 위치한 데이터를 소멸하지 않고 반환
      ・ 덱의 머리에 위치한 데이터를 소멸하지 않고 반환

      void DequeInit(Deque *pdeq);
      - 덱의 초기화를 진행
      - 덱 생성 후 제일 먼저 호출되어야 하는 함수

      int DQIsEmpty(Deque *pdeq);
      - 덱이 빈 경우 TRUE, 그렇지 않은 경우 FALSE

      void DQAddFirst(Deque *pdeq, Data data);
      - 덱의 머리에 데이터를 저장

      void DQAddLast(Deque *pdeq, Data data);
      - 덱의 꼬리에 데이터를 저장

      Data DQRemoveFirst(Deque *pdeq);
      - 덱의 머리에 위치한 데이터를 반환 및 소멸

      Data DQRemoveLast(Deque *pdeq);
      - 덱의 꼬리에 위치한 데이터를 반환 및 소멸

      Data DQGetFirst(Deque *pdeq);
      - 덱의 머리에 위치한 데이터를 소멸하지 않고 반환

      Data DQGetLast(Deque *pdeq);
      - 덱의 꼬리에 위치한 데이터를 소멸하지 않고 반환
   ```
