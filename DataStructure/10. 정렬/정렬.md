## 단순한 정렬 알고리즘

1. 버블 정렬 알고리즘

   1. 버블정렬은 인접한 두 개의 데이터를 비교해가면서 정렬을 진행하는 정렬 알고리즘이다.
   2. 버블정렬의 알고리즘 전략 (오름차순일 경우)  
      ① 첫번째 요소부터 인접한 데이터를 비교하여, 정렬 순서상 위치가 바뀌어야하는 경우 두 데이터의 위치를 바꾼다.  
      ② 정렬이 완료된 배열의 끝에 위치한 데이터를 제외하고 나머지를 대상으로 비교와 교환을 다시 진행한다.  
      \* 위의 과정이 반복되면 데이터가 정렬된다.
   3. 버블 정렬의 시간 복잡도  
      ① 비교연산에 의한 시간복잡도 : O(n^2)  
      ② 데이터 이동연산에 의한 시간복잡도: O(n^2)

2. 선택 정렬 알고리즘

   1. 선택정렬은 최솟값을 찾아서 첫 번째부터 마지막 요소까지 순차적으로 정렬하는 알고리즘이다.
   2. 선택정렬의 알고리즘 전략  
      ① 첫 번째 요소가 가장 작은 값이라 가정한다.  
      ② 두 번째 요소부터 마지막 요소까지 순차적으로 비교하여 최솟값을 찾는다.  
      ③ 최솟값이 위치한 요소와 첫 번째 요소의 위치를 변경한다.  
      ④ 두 번째 요소가 가장 작은 값이라고 가정한다.

      ⑤ 세 번째 요소부터 마지막 요소까지 순차적으로 비교하여 최솟값을 찾는다.  
      ⑥ 최솟값이 위치한 요소와 두 번째 요소의 위치를 변경한다.  
      ⑦ 세 번째 요소가 가장 작은 값이라고 가정한다.

      ⑧ 네 번째 요소부터 마지막 요소까지 순차적으로 비교하여 최솟값을 찾는다.  
      ⑨ 최솟값이 위치한 요소와 세 번째 요소의 위치를 변경한다.

      - 위의 세가지 과정이 반복됨을 알 수 있다. 이 과정은 정렬이 끝날 때까지 반복된다.

   3. 선택 정렬의 시간 복잡도  
      ① 비교연산에 의한 시간복잡도 : O(n^2)  
      ② 데이터 이동연산에 의한 시간복잡도: O(n)

3. 삽입 정렬 알고리즘
   1. 삽입정렬은 정렬 대상을 2부분으로 나눠서, 정렬안된 부분에 있는 데이터를 정렬된 부분의 특정 위치에 삽입해 가면서 정렬을 진행하는 알고리즘이다.
   2. 삽입정렬의 알고리즘 전략  
      ① 정렬이 완료된 영역의 다음에 위치한 데이터가 그 다음 정렬대상이다.  
      ② 정렬대상이 정렬이 완료된 영역의 요소들과 하나씩 비교하며 자기가 정렬될 위치를 찾는다. (비교하여 데이터를 한 칸씩 뒤로 밀면서 위치를 찾는다.)  
      \* 위의 과정이 반복되면 데이터가 정렬된다.
   3. 삽입 정렬의 시간 복잡도  
      ① 비교연산에 의한 시간복잡도- 최선의 경우: O(0) 최악의 경우: O(n^2)  
      ② 데이터 이동연산에 의한 시간복잡도- 최선의 경우: O(0) 최악의 경우: O(n^2)

## 복잡하지만 효율적인 정렬 알고리즘

1. 힙 정렬 알고리즘

   1. 힙 정렬은 힙 자료구조를 이용하여 정렬하는 알고리즘이다.
   2. 힙 정렬의 알고리즘 전략  
       ① 정렬 대상인 데이터들을 힙에 넣어준다. (힙의 루트노드에 저장된 값이 가장 크다 or 앞선다 라는 특성을 이용)  
       ② 힙에 저장한 데이터를 하나씩 삭제하며 출력하여 배열에 순차적으로 저장해주면, 정렬이 완료된다.  
      3)힙 정렬의 시간 복잡도  
       ① 비교연산에 의한 시간복잡도- 최선의 경우: O(0) 최악의 경우: O(logN)  
       ② 데이터 이동연산에 의한 시간복잡도- 최선의 경우: O(0) 최악의 경우: O(N \* logN)

2. 병합 정렬 알고리즘

   1. 병합 정렬은 분할 정복(Divide and Conquer)이라는 알고리즘 디자인 기법에 근거하여 만들어진 정렬 알고리즘이다.
   2. 병합 정렬의 알고리즘 전략  
      ① 모든 데이터는 우선 분할의 과정을 거치며, 요소가 한 개가 될 때까지 분할한다. (분할을 할 때에는 정렬을 고려하지 않고 그저 분할만 하면 된다.)  
      ② 분할이 완료되었다면 병합을 시작하는데, 병합을 할 때부터 정렬순서를 고려해서 묶는다.
   3. 분할과 병합은 재귀적 성질을 가진다.
   4. 병합 정렬의 시간 복잡도  
      ① 비교연산에 의한 시간복잡도: O(N*logN)  
      ② 데이터 이동연산에 의한 시간복잡도: O(N*logN)  
      \* 정렬의 대상인 데이터의 수가 n개 일 때, 각 병합의 단계마다 최대 n번의 비교연산이 진행된다.  
      \* 데이터의 수가 8개 일 땐 병합의 과정이 3번, 데이터의 수가 16개 일 땐 병합의 과정이4번이므로 logN에 따른다고 할 수 있다.  
      \* 한 단계의 최대 비교연산 _ 병합의 과정 = N _ logN

3. 퀵 정렬 알고리즘

   1. 퀵 정렬은 분할 정복(Divide and Conquer)이라는 알고리즘 디자인 기법에 근거하여 만들어진 정렬 알고리즘이다.
   2. 퀵 정렬의 용어 정리  
      ① pivot: 정렬을 진행하는데 필요한 일종의 기준이다. (pivot을 기준으로 left와 right의 값을 변경한다.)  
      ② left: 정렬 대상의 가장 왼쪽 지점  
      ③ right: 정렬 대상의 가장 오른쪽 지점  
      ④ low: 피벗을 제외한 가장 왼쪽에 위치한 지점  
      ⑤ high: 피벗을 제외한 가장 오른쪽에 위치한 지점
   3. 퀵 정렬의 알고리즘 전략 (오름차순)  
      ① pivot을 하나 정한다. (pivot은 개발자가 정하기 나름이지만, 중간 값을 정하는게 성능이 가장 좋다.)  
      ② low는 오른쪽으로, high는 왼쪽으로 이동하며, low는 pivot보다 정렬의 우선순위가 낮은 데이터를 만날 때까지, high는 pivot보다 정렬의 우선순위가 높은 데이터를 만날 때까지 이동한다.  
      ③ low와 high의 값을 교환해준다.  
      ④ 왼쪽에서 시작한 row가 오른쪽에서 시작한 high보다 커질 때까지 위의 작업을 반복한다.  
      ⑤ (low > high)일 경우 high의 위치에 pivot을 놓아두고, pivot을 기준으로 왼쪽 영역과 오른쪽 영역을 다시 퀵정렬 함수에 넣어준다.(재귀적 특성 이용)
   4. 퀵 정렬의 시간 복잡도  
      ① 비교연산에 의한 시간복잡도: O(N\*logN)

4. 기수 정렬 알고리즘(LSD vs MSD)
   1. 기수 정렬은 정렬 순서를 비교하지 않고 정렬하는 방법이다.
   2. 용어정리  
      ① 기수(Radix)란 주어진 데이터를 구성하는 기본 요소를 의미한다. (ex: 10진법은 0~9까지의 수로 구성되므로 0~9가 기본요소이자 기수이다.)  
      ② 버킷(Bucket)은 기수를 저장하기 위한 저장 공간이다. 보통 큐로 구현하여 저장한다.
   3. 기수 정렬의 방법으로 LSD와 MSD가 존재한다.  
      ① LSD (Least Significant Digit): 덜 중요한 자릿수부터 정렬을 진행하는 방법으로, 일의 자리부터 비교해나가는 방법이다.  
      ② MSD (Most Significant Digit): 가장 중요한 자릿수부터 정렬을 진행하는 방법으로, 제일 높은 자릿수부터 비교해나가는 방법이다.
   4. LSD는 일의 자리부터 기수를 분석하여 버킷에 담고, 버킷의 순서에 따라 출력하여 배열에 저장하는 방법으로 정렬을 한다.
   5. 기수 정렬의 알고리즘 전략 (오름차순)  
      ① 타겟 숫자에서 일의 자리수의 숫자를 추출한다.  
      ② 추출한 일의 자리수의 기수를 판단하여 버킷에 저장한다. 모든 정렬 대상을 대상으로 진행한다.  
      ③ 버킷의 순서에 따라 데이터를 추출하여 배열에 저장한다.  
      ④ 정렬 대상중 가장 긴 데이터에 맞춰서 자릿수 비교를 한다.  
      \* 위의 과정이 끝나면 정렬이 완료된다.
   6. 퀵 정렬의 시간 복잡도  
      ① 데이터 삽입과 추출의 빈도수에 의한 시간복잡도: O(n)
