# 우선순위 큐와 힙

## 우선순위 큐의 이해

1. 우선순위 큐는 FIFO구조를 가지는 큐와는 다르게, 들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나온다.
2. 우선순위를 판별하는 기준은 개발자의 목표에 따라 달라진다. (정수 판단, 문자열 순서 판단, 숫자가 클수록, 숫자가 작을수록 etc)
3. 우선순위 큐는 배열, 연결리스트, 힙을 통해 구현할 수 있다.
   1. 배열로 구현할 경우의 단점  
      ① 데이터 삽입 or 삭제 과정에서 데이터를 한 칸씩 밀어내거나 당기는 연산이 수반된다.  
      ② 삽입 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위 비교를 해야할 수 있다.
   2. 연결리스트로 구현할 경우의 단점  
      ① 삽입 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위 비교를 해야할 수 있다.
      배열의 단점 1번은 해결되지만, 여전히 단점이 남아 있다.
   - 배열과 연결리스트로 우선순위 큐를 구현하는 방법은 간단하지만, 단점이 존재하기 때문에 보통은 힙으로 구현한다.

## 힙이란

1. 힙이란 완전 이진트리의 구조를 가지며, 모든 노드에 저장된 값은 자식노드에 저장된 값보다 크거나 같아야하는 특성이 있다. 여기서 자식 노드에 저장된 값을 우선순위라고 생각한다면 우리가 원하는 우선순위 큐를 구현하는 것과 같음을 알 수 있다. 하지만 우선순위 큐와 힙은 엄연히 다른 자료구조이므로 구분을 해야한다. (우선순위 큐는 우선순위가 높은 데이터를 추출하기 위한 자료구조임을 기억해야한다.)
2. 최대힙(Max Heap)과 최소힙(Min Heap)은 힙의 한 종류이다.  
   ① 최대힙: 루트로 올라갈수록 저장된 값이 커진다.  
   ② 최소힙: 루트로 올라갈수록 저장된 값이 작아진다.
3. 최대힙이든 최소힙이든 우선순위로 생각하면 결국 같아지므로, 힙을 이용하여 우선순위 큐를 구현한다.
4. 힙은 배열로 구현하는 것이 좋다. 그 이후는 최대힙과 최소힙을 위한 알고리즘 전략상 데이터를 삽입할 때 마지막 노드에 데이터를 추가해야하는데, 연결리스트로 구현하기 까다롭다.

## 힙 구현 알고리즘 전략

1. 최소힙 데이터 삽입의 알고리즘 전략  
   ① 새로운 데이터는 우선순위가 제일 낮다는 가정 하에서 마지막 위치에 저장한다. (힙은 완전 이진트리이므로, 마지막 레벨의 가장 오른쪽에 위치한 노드의 다음에 저장하면 된다.)  
   ② 부모 노드와 비교해서 값이 더 작을 경우 부모 노드와 위치를 변경한다. (반복 - 부모노드가 더 작아질 때까지)
2. 최소힙 데이터 삭제의 알고리즘 전략  
   ① 마지막에 저장되어 있는 노드를 루트노드로 옮긴다.  
   ② 자식노드 중 값이 더 작은 값과 비교해서 값이 더 큰 경우 위치를 변경한다. (반복 - 자식노드보다 작아질 때까지)
3. 배열을 통해 힙을 구현할 때 전략
   1. 배열의 인덱스 0번은 배열요소로 사용하지 않는다. 그 이유는 힙에 저장된 노드의 개수와 마지막 노드의 고유 번호를 일치시키기 위해서이다.
   2. 노드의 인덱스 값을 얻는 방법  
      ① 부모 노드의 인덱스값 : 자식노드의 인덱스값 / 2  
      ② 왼쪽 자식 노드의 인덱스값: 부모노드의 인덱스값 _ 2  
      ③ 오른쪽 자식 노드의 인덱스값: 부모노드의 인덱스값 _ 2 + 1

## 구현 방법에 따른 성능 평가

1. 배열로 구현한 경우
   ```
   ① 저장의 시간복잡도: O(N)
   ② 삭제의 시간복잡도: O(1)
   ```
2. 연결리스트로 구현한 경우
   ```
   ① 저장의 시간복잡도: O(N)
   ② 삭제의 시간복잡도: O(1)
   ```
3. 힙으로 구현한 경우
   ```
   ① 저장의 시간복잡도: O(logN) →　힙을 기반으로 하면 트리의 높이에 해당하는 수만큼만    비교연산을 진행하면 되기 때문에...
   ② 삭제의 시간복잡도: O(logN)
   ```
